# Feature Request: Single-Stepping (Step Into)

## 1. Summary

This document proposes the addition of a single-stepping feature to the debugger. The initial focus will be on implementing "Step Into" functionality for both x64 and ARM64 architectures on the Windows platform. This is a foundational feature for any debugger, allowing users to execute a program one instruction at a time to observe its behavior in detail.

## 2. Motivation

Fine-grained code execution control is essential for debugging. Developers need to trace execution paths, inspect register and memory states after each instruction, and understand complex algorithms or identify the root cause of subtle bugs. The absence of stepping capabilities severely limits the debugger's utility.

## 3. Proposed Changes

To implement this feature, changes are required in the communication protocol, the platform-agnostic interface, and the Windows-specific implementation.

### 3.1. Protocol Changes (`src/protocol.rs`)

A new request is needed to initiate a step, and a new debug event is required to notify the client when the step is complete.

**`DebuggerRequest` Enum:**
A new variant will be added to allow the client to request a step.

```rust
// in enum DebuggerRequest
StepInto { pid: u32, tid: u32 },
```

**`DebugEvent` Enum:**
A new event variant is needed to signal that a single-step operation has completed. This event will be generated by the debug loop when it receives a `SINGLE_STEP` exception from the operating system.

```rust
// in enum DebugEvent
SingleStep {
    pid: u32,
    tid: u32,
    address: u64,
},
```

### 3.2. Platform Interface Changes (`src/interfaces.rs`)

The `PlatformAPI` trait needs a new method to abstract the stepping operation.

**`PlatformAPI` Trait:**
```rust
pub trait PlatformAPI: Send + Sync {
    // ... existing methods
    fn step_into(&mut self, pid: u32, tid: u32) -> Result<Option<crate::protocol::DebugEvent>, PlatformError>;
    // ... existing methods
}
```

This method will instruct the target process to execute a single instruction in the specified thread and then stop. The result should be a `DebugEvent::SingleStep`.

### 3.3. Windows Implementation Outline (`src/windows_platform/`)

The core logic will reside in the `WindowsPlatform` implementation of the `PlatformAPI`. A new file, `src/windows_platform/stepping.rs`, should be created to house the stepping logic.

**`src/windows_platform/mod.rs`:**
The `step_into` method will be added to the `impl PlatformAPI for WindowsPlatform`.

```rust
// in impl PlatformAPI for WindowsPlatform
fn step_into(&mut self, pid: u32, tid: u32) -> Result<Option<crate::protocol::DebugEvent>, PlatformError> {
    // Delegate to the new stepping module
    stepping::step_into(self, pid, tid)
}
```

**`src/windows_platform/stepping.rs` (New File):**
This new module will contain the implementation details for `step_into`.

The high-level logic is:
1.  Get a mutable reference to the `DebuggedProcess`.
2.  Retrieve the `CONTEXT` for the target thread using `get_thread_context`.
3.  Modify the `CONTEXT` to enable single-stepping based on the architecture.
    *   **For x64:** Set the Trap Flag (TF) in the `EFlags` register. `EFlags` is bit 8. `context.EFlags |= 1 << 8;`
    *   **For ARM64:** Set the single-step bit in the `CONTEXT` structure. This is managed via the `DbgControl` field, which needs to be set to enable single-stepping.
4.  Apply the modified `CONTEXT` back to the thread using `set_thread_context`.
5.  Resume execution of the debuggee using `debug_events::continue_exec`.
6.  The operating system will execute one instruction and then raise a `STATUS_SINGLE_STEP` exception.
7.  The existing debug loop in `debug_events.rs` must be updated to handle `EXCEPTION_SINGLE_STEP`. When this exception occurs, it should:
    *   Create the new `DebugEvent::SingleStep`.
    *   Return this event to the client.
    *   **Crucially**, the Trap Flag is automatically cleared by the CPU after the exception, so it does not need to be manually reset before the next continue.

## 4. Task Breakdown

1.  **Protocol:** Add `StepInto` to `DebuggerRequest` and `SingleStep` to `DebugEvent` in `src/protocol.rs`.
2.  **Interface:** Add the `step_into` method signature to the `PlatformAPI` trait in `src/interfaces.rs`.
3.  **Implementation Stub:** Add the `step_into` method to `impl PlatformAPI for WindowsPlatform` in `src/windows_platform/mod.rs` and create the new `src/windows_platform/stepping.rs` file.
4.  **Stepping Logic:** Implement the `step_into` function in `stepping.rs`, including getting context, setting the appropriate flags for x64 and ARM64, and setting the context.
5.  **Debug Loop:** Modify `debug_events::continue_exec` to handle the `EXCEPTION_SINGLE_STEP` case and return the `DebugEvent::SingleStep` event.
6.  **Server Logic:** Update the main server loop in `src/server.rs` to handle the new `DebuggerRequest::StepInto` and call the `platform.step_into()` method.
7.  **Testing:** Add a new test case in the `tests/` directory to verify the step-into functionality.
