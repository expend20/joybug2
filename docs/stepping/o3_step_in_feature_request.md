# Feature Request: Unified Stepper Interface (Step In / Step Over / Step Out)

## 1  Motivation
A robust stepping mechanism is a core capability for any debugger.  Our current Windows-only implementation lacks a dedicated, reusable interface for single-step execution and does not yet support ARM64.  This proposal introduces a **unified stepper interface** that supports both **x64** and **AArch64** (ARM64) architectures and lays the groundwork for future Step Over and Step Out operations.

## 2  Scope (Phase 1)
* Implement *Step In* only (single instruction execution)
* Architect the solution so Step Over / Step Out can reuse the same primitives
* Support the Windows platform first, but design abstractions to allow future Unix/macOS back-ends

## 3  Design Goals
1. **Consistency** – identical API shape for all architectures
2. **Safety** – thread-safe operations; guarantee Trap Flag / single-step bit cleanup
3. **Extensibility** – easy to plug new back-ends or architectures
4. **Non-blocking** – stepping should integrate with the existing async/event-driven debug loop

## 4  Proposed Public API Changes
### 4.1  `protocol.rs`
```rust
#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type", content = "data")]
pub enum DebuggerRequest {
    // … existing variants …
    Step {
        pid: u32,
        tid: u32,
        kind: StepKind, // new enum (see below)
    },
}

#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq, Eq)]
pub enum StepKind {
    Into,
    Over,
    Out,
}

// Response sent **after** the step completes (i.e. after STATUS_SINGLE_STEP is handled)
#[derive(Serialize, Deserialize, Clone)]
#[serde(tag = "type", content = "data")]
pub enum DebuggerResponse {
    // … existing variants …
    StepComplete {
        pid: u32,
        tid: u32,
        kind: StepKind,
    },
}
```

### 4.2  `interfaces.rs` – new trait & method
```rust
pub trait Stepper {
    fn step(&mut self, pid: u32, tid: u32, kind: StepKind) -> Result<Option<DebugEvent>, PlatformError>;
}

// `WindowsPlatform` will `impl Stepper`.
// Eventually the methods can be folded into `PlatformAPI`, but a standalone trait keeps the change minimal.
```

### 4.3  `mod.rs` (per-platform)
Add a new `stepper` sub-module for each platform (`windows_platform/stepper.rs`, etc.) that contains the architecture-specific logic described below.

## 5  Architecture-Specific Behaviour
### 5.1  x64 (Intel / AMD‐64)
1. **Get Thread Context** using existing `get_thread_context` helper
2. **Set Trap Flag (TF)** – `context.EFlags |= 0x100`
3. **Set Thread Context**
4. **Resume Thread** (already handled in `continue_exec` when returning `DebugEvent::Ack`)
5. On `STATUS_SINGLE_STEP` exception, clear TF, package a `StepComplete` response

### 5.2  AArch64 (ARM64)
1. Read thread context via `GetThreadContext` (NT_TIB / `CONTEXT_ARM64`)
2. **Set SS (Single-Step) bit** in `MDSCR_EL1` (bit 0) *or* `PSTATE.DIT` depending on OS version
3. Write context back
4. Resume thread; wait for `STATUS_SINGLE_STEP`
5. Clear SS bit; return `StepComplete`

### 5.3  Common Clean-up Path
* Always clear the single-step flag before resuming normal execution, even if the debugger request fails mid-way

## 6  Step Over / Step Out Road-Map (Not in Phase 1)
* **Disassembler Integration** – use `CapstoneDisassembler` already in tree to detect `CALL` / `BL` / `RET` instructions and place one-shot software breakpoints
* **Breakpoint Manager** – probably extracted from existing functionality in `windows_platform::debug_events`
* **Call-Frame Analysis** – leverage `get_call_stack` for Step Out termination condition

## 7  Additional Work Needed
| Area | Task | Priority |
|------|------|----------|
| Exception Handling | Surface `STATUS_SINGLE_STEP` as a `DebugEvent::Breakpoint` or dedicated `SingleStep` variant | High |
| Code | Create `windows_platform/stepper.rs` with per-arch flag manipulation helpers | High |
| API | Implement `Stepper` for `WindowsPlatform` and forward through server layer | High |
| Tests | Add unit + integration tests in `tests/step_in_test.rs` simulating x64 & ARM64 threads | Med |
| Docs | Update README & protocol documentation | Med |
| Future | Extend to Step Over / Step Out using disassembler + breakpoints | Low |

## 8  Open Questions
1. Should `StepComplete` replace the existing `DebugEvent::Breakpoint` for single-step, or live alongside it?
2. Do we need per-thread stepping queues (allow multiple pending requests)?
3. How to handle multi-threaded targets when stepping a single thread – suspend others?

## 9  Acceptance Criteria
* Sending `DebuggerRequest::Step { kind: Into, … }` performs exactly **one** instruction on both x64 & ARM64
* `StepComplete` is received with no extra side effects
* All registers (besides TF / SS) remain unchanged
* No stray breakpoints or flags after completion

---
*Generated by o3 assistant — based on analysis of TitanEngine, koidbg, and GleeBug stepping implementations.*
